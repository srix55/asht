<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The overall procedure is to first have an idea about the ui, implement the corresponding usecases on the server side - usecases & repos & database. Then, codegen the stubs for dart side, implement the UI and finally, e2e tests.


  Server-side
  #


  Usecase
  #


Generate usecase skeleton

generate usecase with Tuxfrog Usecase J
move usecaseImplTest to corresponding test package


Define the exceptions at the usecase - note checked & unchecked exceptions
UsecaseImpl, tests first

Request validation
Permissions check
Exceptions check
Update version, if state changed by UpdateVersion.updateVersion


Tests

Permissions
Request Validation
Exceptions test
Version update test, if needed




  Repo
  #


Generate repoImpl with Tuxfrog Repo J
Wire up the factory to usecase&rsquo;s repoFactoryProvider in appInit & testConfig&rsquo;s beforeIntegrationTests main of quarkus-app
Design the database

signage/devops/database - init.sql and inserts.sql (remember: avoid postgres enums)
DAOs and DaoAdapters
Add id (if any) and DAO in persistence/src/main/resources/META-INF/persistence.xml


With integration tests first, write the repoImpl


  Endpoints
  #


Write the REST openAPI specs

Spec definitions at api/openapi/specs
Validate the specs - openapi lint specs/openapi.yaml
Bundle the specs - openapi bundle --output dist/openapi.yaml specs/openapi.yaml
Run ./gradlew build -x test


REST endpoint impl

Request validation
Exceptions with reasonPhrases
RestAdapters
Exception handling & catchAll logging
endpointTests - happy flow & exceptions





  Client-side
  #


  Frontend
  #


UI-UX first - prototype to cubit impl
Draw the prototype in paper or tools like PenPot
See if any new basic components need to be added in TuxKit

Create the basic component, with options for variants. Do not overthink and add variants for future usecases
Basic component should be able to scale

in size
colors - dark mode


Use ebay&rsquo;s golden_toolkit for testing

basic ui test
language change
dark mode
business logic (for example, button disabled if permission not given to user)




StatefulWidget or StatelessWidget (for simpler widgets)
Have a View widget that gets the cubit
Use translations where needed

Use i18n_helper project for language translations

Add variable in app_en.arb (in lib/l10n)
Add translations for desired languages (currently using es for testing)
Run the i18n_helper and copy arb files into your lib/language dir and all files in .dart_tool/flutter_gen/gen_l10n except app_localizations.dart
Manually copy the variables from i18n_helper&rsquo;s app_localizations.dart to project&rsquo;s app_localizations.dart




Note that some languages are lengthy by nature. For ex, cancel in german is some big word
Use LayoutBuilder with if (constraints.maxWidth < theme.spacing.xxxl * x) for responsive designs
Are forms involved?

Has permission to edit / delete ?

Show inability to edit/delete with toast message when tried


Enclose in form and add validation for every field
Make sure every field is foolproof (for ex, max input length for textformfield)
Support on multi-language input with languageButtonToggle
Implementation points

TextEditingControllers stored in stateful widget&rsquo;s state and not in cubit
Sent to cubit on save only
Error display logic and storing edit states in stateful widget only and not in cubit


Run on android device to be safe


Cubit & CubitData


  Usecase
  #


Generate usecase skeleton

generate usecase with Tuxfrog Usecase
move usecaseImplTest to corresponding test package


Export the usecase files - repo, repo-factory-provider, usecase,  usecase-factory-provider


  Rest Client Gen
  #


Go to signage/client/codegen
Run generate-dart-client.sh
Copy the contents of generated/rest into rest_client of signage-admin/signage-player
Open it in idea and run pub-get and dart run build_runner build
*-repos should use the rest_client in pubspec.yaml
rest_client:
  path: ../rest_client

Change the api base path in api.dart


  Repo
  #


Generate the repo skeleton

generate the repo with Tuxfrog Repo
move repoImplTest to corresponding test package


Remember that isolates DON&rsquo;T share memory

"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/dev/"><meta property="og:site_name" content="Signage Docs"><meta property="og:title" content="Dev"><meta property="og:description" content="The overall procedure is to first have an idea about the ui, implement the corresponding usecases on the server side - usecases & repos & database. Then, codegen the stubs for dart side, implement the UI and finally, e2e tests.
Server-side # Usecase # Generate usecase skeleton generate usecase with Tuxfrog Usecase J move usecaseImplTest to corresponding test package Define the exceptions at the usecase - note checked & unchecked exceptions UsecaseImpl, tests first Request validation Permissions check Exceptions check Update version, if state changed by UpdateVersion.updateVersion Tests Permissions Request Validation Exceptions test Version update test, if needed Repo # Generate repoImpl with Tuxfrog Repo J Wire up the factory to usecase’s repoFactoryProvider in appInit & testConfig’s beforeIntegrationTests main of quarkus-app Design the database signage/devops/database - init.sql and inserts.sql (remember: avoid postgres enums) DAOs and DaoAdapters Add id (if any) and DAO in persistence/src/main/resources/META-INF/persistence.xml With integration tests first, write the repoImpl Endpoints # Write the REST openAPI specs Spec definitions at api/openapi/specs Validate the specs - openapi lint specs/openapi.yaml Bundle the specs - openapi bundle --output dist/openapi.yaml specs/openapi.yaml Run ./gradlew build -x test REST endpoint impl Request validation Exceptions with reasonPhrases RestAdapters Exception handling & catchAll logging endpointTests - happy flow & exceptions Client-side # Frontend # UI-UX first - prototype to cubit impl Draw the prototype in paper or tools like PenPot See if any new basic components need to be added in TuxKit Create the basic component, with options for variants. Do not overthink and add variants for future usecases Basic component should be able to scale in size colors - dark mode Use ebay’s golden_toolkit for testing basic ui test language change dark mode business logic (for example, button disabled if permission not given to user) StatefulWidget or StatelessWidget (for simpler widgets) Have a View widget that gets the cubit Use translations where needed Use i18n_helper project for language translations Add variable in app_en.arb (in lib/l10n) Add translations for desired languages (currently using es for testing) Run the i18n_helper and copy arb files into your lib/language dir and all files in .dart_tool/flutter_gen/gen_l10n except app_localizations.dart Manually copy the variables from i18n_helper’s app_localizations.dart to project’s app_localizations.dart Note that some languages are lengthy by nature. For ex, cancel in german is some big word Use LayoutBuilder with if (constraints.maxWidth < theme.spacing.xxxl * x) for responsive designs Are forms involved? Has permission to edit / delete ? Show inability to edit/delete with toast message when tried Enclose in form and add validation for every field Make sure every field is foolproof (for ex, max input length for textformfield) Support on multi-language input with languageButtonToggle Implementation points TextEditingControllers stored in stateful widget’s state and not in cubit Sent to cubit on save only Error display logic and storing edit states in stateful widget only and not in cubit Run on android device to be safe Cubit & CubitData Usecase # Generate usecase skeleton generate usecase with Tuxfrog Usecase move usecaseImplTest to corresponding test package Export the usecase files - repo, repo-factory-provider, usecase, usecase-factory-provider Rest Client Gen # Go to signage/client/codegen Run generate-dart-client.sh Copy the contents of generated/rest into rest_client of signage-admin/signage-player Open it in idea and run pub-get and dart run build_runner build *-repos should use the rest_client in pubspec.yaml rest_client: path: ../rest_client Change the api base path in api.dart Repo # Generate the repo skeleton generate the repo with Tuxfrog Repo move repoImplTest to corresponding test package Remember that isolates DON’T share memory"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Dev | Signage Docs</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/dev/><link rel=stylesheet href=/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5+NfY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.8055c20c11bab2948f35a214cd3b34d0049bc9809df8d235cf0b2e0a5e3b3140.js integrity="sha256-gFXCDBG6spSPNaIUzTs00ASbyYCd+NI1zwsuCl47MUA=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/docs/dev/index.xml title="Signage Docs"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Signage Docs</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-5fdf93cd314ec47df39ee998b89605b2 class=toggle>
<label for=section-5fdf93cd314ec47df39ee998b89605b2 class="flex justify-between"><a href=/docs/caching/>Caching</a></label><ul><li><a href=/docs/caching/strategy/>Strategy</a><ul></ul></li><li><a href=/docs/caching/data-structures/>Data Structures</a><ul></ul></li><li><a href=/docs/caching/scenarios/>Scenarios</a><ul></ul></li></ul></li><li><input type=checkbox id=section-4e5caaf6365b6353a122fd9e35c00b08 class=toggle checked>
<label for=section-4e5caaf6365b6353a122fd9e35c00b08 class="flex justify-between"><a href=/docs/dev/ class=active>Dev</a></label><ul><li><input type=checkbox id=section-93509623b841973ade448228f6a7245a class=toggle>
<label for=section-93509623b841973ade448228f6a7245a class="flex justify-between"><a href=/docs/dev/checklists/>Checklists</a></label><ul><li><input type=checkbox id=section-cd85b26f7f821c87127cc7c5ab2be114 class=toggle>
<label for=section-cd85b26f7f821c87127cc7c5ab2be114 class="flex justify-between"><a href=/docs/dev/checklists/flutter_ui/>Flutter UI</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-342701e3704fa08e1bf5178f22301bff class=toggle>
<label for=section-342701e3704fa08e1bf5178f22301bff class="flex justify-between"><a href=/docs/dev/gcp/>GCP Deploy</a></label><ul></ul></li><li><input type=checkbox id=section-62f6752f338b4e8972e68d919e388f1b class=toggle>
<label for=section-62f6752f338b4e8972e68d919e388f1b class="flex justify-between"><a href=/docs/dev/setup/>Local Setup</a></label><ul></ul></li><li><input type=checkbox id=section-8a7fd608f954780ffa4e272058ad1f8f class=toggle>
<label for=section-8a7fd608f954780ffa4e272058ad1f8f class="flex justify-between"><a href=/docs/dev/setup_fedora/>Local Setup (Fedora)</a></label><ul></ul></li><li><input type=checkbox id=section-a4a95fe5b98a6ee596e16de8c518475a class=toggle>
<label for=section-a4a95fe5b98a6ee596e16de8c518475a class="flex justify-between"><a href=/docs/dev/mac/>Mac</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-20d497b48986a632cbad2fbd9940c776 class=toggle>
<label for=section-20d497b48986a632cbad2fbd9940c776 class="flex justify-between"><a href=/docs/manual/>Dev Manual</a></label><ul></ul></li><li><input type=checkbox id=section-2f9d02b5146d32013b75800d20839f0c class=toggle>
<label for=section-2f9d02b5146d32013b75800d20839f0c class="flex justify-between"><a href=/docs/player_registration/>Player Registration</a></label><ul></ul></li><li><input type=checkbox id=section-401ec0f4fea4e1b33d16a959f93c7b54 class=toggle>
<label for=section-401ec0f4fea4e1b33d16a959f93c7b54 class="flex justify-between"><a href=/docs/cheats/>Cheats</a></label><ul><li><a href=/docs/cheats/http/>Http</a><ul></ul></li></ul></li><li><input type=checkbox id=section-b439b1f12afb2bdb787d45ce1eefc920 class=toggle>
<label for=section-b439b1f12afb2bdb787d45ce1eefc920 class="flex justify-between"><a href=/docs/snippets/>Snippets</a></label><ul><li><a href=/docs/snippets/jpa/>JPA</a><ul></ul></li><li><a href=/docs/snippets/rest/>Rest</a><ul></ul></li><li><a href=/docs/snippets/dart/>Dart</a><ul></ul></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Dev</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#server-side>Server-side</a><ul><li><ul><li><a href=#__usecase__><strong>Usecase</strong></a></li><li><a href=#__repo__><strong>Repo</strong></a></li><li><a href=#__endpoints__><strong>Endpoints</strong></a></li></ul></li></ul></li><li><a href=#client-side>Client-side</a><ul><li><ul><li><a href=#__frontend__><strong>Frontend</strong></a></li><li><a href=#__usecase__-1><strong>Usecase</strong></a></li><li><a href=#__rest-client-gen__><strong>Rest Client Gen</strong></a></li><li><a href=#__repo__-1><strong>Repo</strong></a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p>The overall procedure is to first have an idea about the ui, implement the corresponding usecases on the server side - usecases & repos & database. Then, codegen the stubs for dart side, implement the UI and finally, e2e tests.</p><hr><h1 id=server-side>Server-side
<a class=anchor href=#server-side>#</a></h1><h3 id=__usecase__><strong>Usecase</strong>
<a class=anchor href=#__usecase__>#</a></h3><ul><li>Generate usecase skeleton<ul><li>generate usecase with <code>Tuxfrog Usecase J</code></li><li>move usecaseImplTest to corresponding test package</li></ul></li><li>Define the exceptions at the usecase - note checked & unchecked exceptions</li><li>UsecaseImpl, tests first<ul><li>Request validation</li><li>Permissions check</li><li>Exceptions check</li><li>Update version, if state changed by <code>UpdateVersion.updateVersion</code></li></ul></li><li>Tests<ul><li>Permissions</li><li>Request Validation</li><li>Exceptions test</li><li>Version update test, if needed</li></ul></li></ul><h3 id=__repo__><strong>Repo</strong>
<a class=anchor href=#__repo__>#</a></h3><ul><li>Generate repoImpl with <code>Tuxfrog Repo J</code></li><li>Wire up the factory to usecase&rsquo;s repoFactoryProvider in appInit & testConfig&rsquo;s beforeIntegrationTests main of quarkus-app</li><li>Design the database<ul><li><code>signage/devops/database</code> - <code>init.sql</code> and <code>inserts.sql</code> (remember: avoid postgres enums)</li><li>DAOs and DaoAdapters</li><li>Add id (if any) and DAO in <code>persistence/src/main/resources/META-INF/persistence.xml</code></li></ul></li><li>With integration tests first, write the repoImpl</li></ul><h3 id=__endpoints__><strong>Endpoints</strong>
<a class=anchor href=#__endpoints__>#</a></h3><ul><li>Write the REST openAPI specs<ul><li>Spec definitions at <code>api/openapi/specs</code></li><li>Validate the specs - <code>openapi lint specs/openapi.yaml</code></li><li>Bundle the specs - <code>openapi bundle --output dist/openapi.yaml specs/openapi.yaml</code></li><li>Run <code>./gradlew build -x test</code></li></ul></li><li>REST endpoint impl<ul><li>Request validation</li><li>Exceptions with reasonPhrases</li><li>RestAdapters</li><li>Exception handling & catchAll logging</li><li>endpointTests - happy flow & exceptions</li></ul></li></ul><hr><h1 id=client-side>Client-side
<a class=anchor href=#client-side>#</a></h1><h3 id=__frontend__><strong>Frontend</strong>
<a class=anchor href=#__frontend__>#</a></h3><ul><li>UI-UX first - prototype to cubit impl</li><li>Draw the prototype in paper or tools like PenPot</li><li>See if any new basic components need to be added in TuxKit<ul><li>Create the basic component, with options for variants. Do not overthink and add variants for future usecases</li><li>Basic component should be able to scale<ul><li>in size</li><li>colors - dark mode</li></ul></li><li>Use ebay&rsquo;s golden_toolkit for testing<ul><li>basic ui test</li><li>language change</li><li>dark mode</li><li>business logic (for example, button disabled if permission not given to user)</li></ul></li></ul></li><li><code>StatefulWidget</code> or <code>StatelessWidget</code> (for simpler widgets)</li><li>Have a View widget that gets the cubit</li><li>Use translations where needed<ul><li>Use <code>i18n_helper</code> project for language translations<ul><li>Add variable in <code>app_en.arb</code> (in lib/l10n)</li><li>Add translations for desired languages (currently using es for testing)</li><li>Run the <code>i18n_helper</code> and copy arb files into your <code>lib/language</code> dir and all files in <code>.dart_tool/flutter_gen/gen_l10n</code> except <code>app_localizations.dart</code></li><li>Manually copy the variables from <code>i18n_helper</code>&rsquo;s <code>app_localizations.dart</code> to project&rsquo;s <code>app_localizations.dart</code></li></ul></li></ul></li><li>Note that some languages are lengthy by nature. For ex, cancel in german is some big word</li><li>Use <code>LayoutBuilder</code> with <code>if (constraints.maxWidth &lt; theme.spacing.xxxl * x)</code> for responsive designs</li><li>Are forms involved?<ul><li>Has permission to edit / delete ?<ul><li>Show inability to edit/delete with toast message when tried</li></ul></li><li>Enclose in <code>form</code> and add validation for every field</li><li>Make sure every field is foolproof (for ex, max input length for textformfield)</li><li>Support on multi-language input with languageButtonToggle</li><li>Implementation points<ul><li>TextEditingControllers stored in stateful widget&rsquo;s state and not in cubit</li><li>Sent to cubit on save only</li><li>Error display logic and storing edit states in stateful widget only and not in cubit</li></ul></li><li>Run on android device to be safe</li></ul></li><li><code>Cubit</code> & <code>CubitData</code></li></ul><h3 id=__usecase__-1><strong>Usecase</strong>
<a class=anchor href=#__usecase__-1>#</a></h3><ul><li>Generate usecase skeleton<ul><li>generate usecase with <code>Tuxfrog Usecase</code></li><li>move usecaseImplTest to corresponding test package</li></ul></li><li>Export the usecase files - repo, repo-factory-provider, usecase, usecase-factory-provider</li></ul><h3 id=__rest-client-gen__><strong>Rest Client Gen</strong>
<a class=anchor href=#__rest-client-gen__>#</a></h3><ul><li>Go to <code>signage/client/codegen</code></li><li>Run <code>generate-dart-client.sh</code></li><li>Copy the contents of <code>generated/rest</code> into <code>rest_client</code> of signage-admin/signage-player</li><li>Open it in idea and run pub-get and <code>dart run build_runner build</code></li><li><code>*-repos</code> should use the <code>rest_client</code> in <code>pubspec.yaml</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>rest_client</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>path</span>: <span style=color:#ae81ff>../rest_client</span>
</span></span></code></pre></div></li><li>Change the api base path in <code>api.dart</code></li></ul><h3 id=__repo__-1><strong>Repo</strong>
<a class=anchor href=#__repo__-1>#</a></h3><ul><li>Generate the repo skeleton<ul><li>generate the repo with <code>Tuxfrog Repo</code></li><li>move repoImplTest to corresponding test package</li></ul></li><li>Remember that isolates DON&rsquo;T share memory</li></ul><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#server-side>Server-side</a><ul><li><ul><li><a href=#__usecase__><strong>Usecase</strong></a></li><li><a href=#__repo__><strong>Repo</strong></a></li><li><a href=#__endpoints__><strong>Endpoints</strong></a></li></ul></li></ul></li><li><a href=#client-side>Client-side</a><ul><li><ul><li><a href=#__frontend__><strong>Frontend</strong></a></li><li><a href=#__usecase__-1><strong>Usecase</strong></a></li><li><a href=#__rest-client-gen__><strong>Rest Client Gen</strong></a></li><li><a href=#__repo__-1><strong>Repo</strong></a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>